/*
 * Copyright 2014 Dario Manesku. All rights reserved.
 * License: http://www.opensource.org/licenses/BSD-2-Clause
 */

#ifndef CMFT_RADIANCEPROGRAM_H_HEADER_GUARD
#define CMFT_RADIANCEPROGRAM_H_HEADER_GUARD

namespace cmft
{
    static const char s_radianceProgramSource[] =
    {
        "typedef unsigned char  uint8_t;\n"
        "typedef unsigned short uint16_t;\n"
        "typedef unsigned int   uint32_t;\n"
        "\n"
        "typedef char  int8_t;\n"
        "typedef short int16_t;\n"
        "typedef int   int32_t;\n"
        "\n"
        "__constant float3 s_faceUvVectors[6][3] =\n"
        "{\n"
        "    { // +x face\n"
        "        {  0.0f,  0.0f, -1.0f }, // u -> -z\n"
        "        {  0.0f, -1.0f,  0.0f }, // v -> -y\n"
        "        {  1.0f,  0.0f,  0.0f }, // +x face\n"
        "    },\n"
        "    { // -x face\n"
        "        {  0.0f,  0.0f,  1.0f }, // u -> +z\n"
        "        {  0.0f, -1.0f,  0.0f }, // v -> -y\n"
        "        { -1.0f,  0.0f,  0.0f }, // -x face\n"
        "    },\n"
        "    { // +y face\n"
        "        {  1.0f,  0.0f,  0.0f }, // u -> +x\n"
        "        {  0.0f,  0.0f,  1.0f }, // v -> +z\n"
        "        {  0.0f,  1.0f,  0.0f }, // +y face\n"
        "    },\n"
        "    { // -y face\n"
        "        {  1.0f,  0.0f,  0.0f }, // u -> +x\n"
        "        {  0.0f,  0.0f, -1.0f }, // v -> -z\n"
        "        {  0.0f, -1.0f,  0.0f }, // -y face\n"
        "    },\n"
        "    { // +z face\n"
        "        {  1.0f,  0.0f,  0.0f }, // u -> +x\n"
        "        {  0.0f, -1.0f,  0.0f }, // v -> -y\n"
        "        {  0.0f,  0.0f,  1.0f }, // +z face\n"
        "    },\n"
        "    { // -z face\n"
        "        { -1.0f,  0.0f,  0.0f }, // u -> -x\n"
        "        {  0.0f, -1.0f,  0.0f }, // v -> -y\n"
        "        {  0.0f,  0.0f, -1.0f }, // -z face\n"
        "    }\n"
        "};\n"
        "\n"
        "static float3 texelCoordToVec(float _u\n"
        "                            , float _v\n"
        "                            , uint8_t _faceId\n"
        "                            , uint32_t _faceSize\n"
        "                            )\n"
        "{\n"
        "    if (1 != _faceSize)\n"
        "    {\n"
        "        // Edge fixup.\n"
        "        // Code from Nvtt : http://code.google.com/p/nvidia-texture-tools/source/browse/trunk/src/nvtt/CubeSurface.cpp\n"
        "        const float faceSizef = (float)_faceSize;\n"
        "        const float faceSizef_Min1 = faceSizef - 1.0f;\n"
        "        const float a = (faceSizef*faceSizef) / (faceSizef_Min1*faceSizef_Min1*faceSizef_Min1);\n"
        "        _u = a * _u*_u*_u + _u;\n"
        "        _v = a * _v*_v*_v + _v;\n"
        "        //const float a = faceSizef*faceSizef / pow(faceSizef - 1.0f, 3.0f);\n"
        "        //_u = a * pow(_u, 3.0f) + _u;\n"
        "        //_v = a * pow(_v, 3.0f) + _v;\n"
        "    }\n"
        "\n"
        "    return normalize(_u * s_faceUvVectors[_faceId][0] + _v * s_faceUvVectors[_faceId][1] + s_faceUvVectors[_faceId][2]);\n"
        "}\n"
        "\n"
        "__constant sampler_t s_imageSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;\n"
        "\n"
        "__kernel void radianceFilter(__write_only image2d_t _out\n"
        "                           , float _specularPower\n"
        "                           , float _specularAngle\n"
        "                           , float _invDstFaceSize_Mul2\n"
        "                           , uint8_t _faceId\n"
        "                           , int32_t _srcFaceSize\n"
        "                           , __read_only image2d_t _srcData0\n"
        "                           , __read_only image2d_t _srcData1\n"
        "                           , __read_only image2d_t _srcData2\n"
        "                           , __read_only image2d_t _srcData3\n"
        "                           , __read_only image2d_t _srcData4\n"
        "                           , __read_only image2d_t _srcData5\n"
        "                           , __read_only image2d_t _normalSolidAngle0\n"
        "                           , __read_only image2d_t _normalSolidAngle1\n"
        "                           , __read_only image2d_t _normalSolidAngle2\n"
        "                           , __read_only image2d_t _normalSolidAngle3\n"
        "                           , __read_only image2d_t _normalSolidAngle4\n"
        "                           , __read_only image2d_t _normalSolidAngle5\n"
        "                           )\n"
        "{\n"
        "    const int row    = get_global_id(0);\n"
        "    const int column = get_global_id(1);\n"
        "\n"
        "    const float vv = (float)row    * _invDstFaceSize_Mul2 - 1.0f;\n"
        "    const float uu = (float)column * _invDstFaceSize_Mul2 - 1.0f;\n"
        "    const float3 tapVec = texelCoordToVec(uu, vv, _faceId, _srcFaceSize);\n"
        "\n"
        "    float4 colorWeight = { 0.0, 0.0, 0.0, 0.0 };\n"
        "    for (int32_t yy = 0; yy < _srcFaceSize; ++yy)\n"
        "    {\n"
        "        for (int32_t xx = 0; xx < _srcFaceSize; ++xx)\n"
        "        {\n"
        "            const int2 coord = { xx, yy };\n"
        "\n"
        "            const float4 normal0 = read_imagef(_normalSolidAngle0, s_imageSampler, coord);\n"
        "            const float4 normal1 = read_imagef(_normalSolidAngle1, s_imageSampler, coord);\n"
        "            const float4 normal2 = read_imagef(_normalSolidAngle2, s_imageSampler, coord);\n"
        "            const float4 normal3 = read_imagef(_normalSolidAngle3, s_imageSampler, coord);\n"
        "            const float4 normal4 = read_imagef(_normalSolidAngle4, s_imageSampler, coord);\n"
        "            const float4 normal5 = read_imagef(_normalSolidAngle5, s_imageSampler, coord);\n"
        "\n"
        "            const float dotProduct0 = dot(normal0.xyz, tapVec);\n"
        "            const float dotProduct1 = dot(normal1.xyz, tapVec);\n"
        "            const float dotProduct2 = dot(normal2.xyz, tapVec);\n"
        "            const float dotProduct3 = dot(normal3.xyz, tapVec);\n"
        "            const float dotProduct4 = dot(normal4.xyz, tapVec);\n"
        "            const float dotProduct5 = dot(normal5.xyz, tapVec);\n"
        "\n"
        "            if (dotProduct0 >= _specularAngle) { colorWeight += read_imagef(_srcData0, s_imageSampler, coord) * normal0.w * native_powr(dotProduct0, _specularPower); }\n"
        "            if (dotProduct1 >= _specularAngle) { colorWeight += read_imagef(_srcData1, s_imageSampler, coord) * normal1.w * native_powr(dotProduct1, _specularPower); }\n"
        "            if (dotProduct2 >= _specularAngle) { colorWeight += read_imagef(_srcData2, s_imageSampler, coord) * normal2.w * native_powr(dotProduct2, _specularPower); }\n"
        "            if (dotProduct3 >= _specularAngle) { colorWeight += read_imagef(_srcData3, s_imageSampler, coord) * normal3.w * native_powr(dotProduct3, _specularPower); }\n"
        "            if (dotProduct4 >= _specularAngle) { colorWeight += read_imagef(_srcData4, s_imageSampler, coord) * normal4.w * native_powr(dotProduct4, _specularPower); }\n"
        "            if (dotProduct5 >= _specularAngle) { colorWeight += read_imagef(_srcData5, s_imageSampler, coord) * normal5.w * native_powr(dotProduct5, _specularPower); }\n"
        "        }\n"
        "    }\n"
        "\n"
        "    if (0.0 != colorWeight.w)\n"
        "    {\n"
        "        colorWeight /= colorWeight.w;\n"
        "    }\n"
        "\n"
        "    const int2 dst = { column, row };\n"
        "    write_imagef(_out, dst, colorWeight);\n"
        "}\n"
    };

} // namespace cmft

#endif // CMFT_RADIANCEPROGRAM_H_HEADER_GUARD
